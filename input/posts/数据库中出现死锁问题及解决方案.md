Title : 数据库中出现死锁问题以及解决方案

Date : 2023-6-25

Tag : 数据库 MSSQL MySQL

---

## 数据库中出现死锁问题以及解决方案

对于数据库死锁问题，目前我暂时还没遇到，但有一定的学习成分在里面，就拿出来写了一篇博客。

死锁（DeadLock）即两个或多个事务相互等待资源，而两边又不释放自己的资源，形成循环导致了死锁。直接上例子：

```mssql
--连接1
BEGIN TRAN;
UPDATE Students SET Name = '张三' WHERE ID = 1;	-- 获得ID为1的行锁
UPDATE Students SET Name = '李四' WHERE ID = 2;	-- 等待锁的释放
```

```mssql
--连接2
BEGIN TRAN;
UPDATE Students SET Name = '李四' WHERE ID = 2;	-- 获得ID为2的行锁
UPDATE Students SET Name = '张三' WHERE ID = 1;	-- 形成死锁
```

这里我们首先执行连接1的前两行，也就是开启事务，然后Update一个ID=1的学生数据。接着执行连接2的前两行，这时候连接1把ID为1的这一行加锁，连接2加锁ID为2的行，这样两行都被加了锁。于是我们继续执行连接1中的事务，Update ID为2的行数据，此时连接1会进入阻塞，等待连接2释放这行数据的锁。最后我们在连接2中再去获取ID为1的行数据，这样就形成了死锁。

原因是1掌控着ID为1的锁，2掌控着ID为2的锁，现在1又要求ID为2的数据，因为一直获取不到，所以一直等待，等待的过程同时也不释放1的锁，最后当2再去获取ID为1的数据，死锁就形成了。如果数据库系统不去干涉，那么死锁会一直进行下去，程序会一直等待。不过数据库会有检测，查询到多个事务相互等待，会强行终止其中一个。

![image-20251001074527287](./images/image-20251001074527287.png)

其实死锁本质上是两个事务都在竞争数据库锁，数据库锁常用的有两种：共享锁和排他锁。

共享锁也叫S锁，目的用于"读"操作，加了锁的数据可以读但不能写，多个事务可以同时加共享锁，也就是大家都能看，但是此时都不能写。SQLServer就会在SELECT的时候短暂的给行加上一个共享锁。

排他锁，X锁，用于"写"操作，叫"排他"就意味着加了锁的行就是独占的资源，其他的事务既不能读，也不能写，直到锁被释放。在上面的例子中，事务里进行的UPDATE操作就会给行加上一个排他锁。

所以说，死锁就是多个事务持有一部分的S锁或X锁，然后又试图去获取其他事务的锁，导致循环等待。

**那么解决办法**，一般情况下数据库会自发的检查死锁产生，然后将最终导致死锁的事务给终结掉，在上面的例子是事务2。我们要做的是尽力避免这种情况产生，再不济也要在程序捕获到死锁异常，来对被作为死锁牺牲品的事务进行逻辑处理或者重试。

最好的选择是，对于读写量不多的表考虑使用乐观锁，减少锁冲突。读写量多的表就做到统一访问顺序，确保所有事务访问资源的顺序一致。如果事先对数据进行排序，保证每个线程按固定的顺序来处理数据，也可以大大降低死锁的产生。
